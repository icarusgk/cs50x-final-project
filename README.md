# CS50x Final Project

This is the repository for the [Harvard's CS50x Final Project](https://cs50.harvard.edu/x/2022/project/)

#### Video Demo: https://youtu.be/O_qeQBoDl5U

### About this project

**CS50x KanBan** is a KanBan board which divides boards across workspaces. Inside each board there are cards that can be dragged between boards. This project is built with Nuxt 3 and Django.

I separated my app into a REST server using the Django REST Framework library and a front-end client using Nuxt 3.

I decided to use [Django REST Framework](https://www.django-rest-framework.org/) for its ease of use when using the server as a REST API. Such easy use is achieved by the use of class based views (APIViews), ModelViewSets, serializers, built-in extended Responses, and auth via JWT's through the `djangorestframework-simplejwt` library. 

On the client side I decided to use the recently launched stable version of the [Nuxt 3 Framework](https://nuxt.com). It features awesome tooling, such as: 
- [Components and Composables auto-imports](https://nuxt.com/docs/guide/concepts/auto-imports) ✨
- [Routing library](https://router.vuejs.org/) 🪧
- Server side rendering 📃
- Different rendering modes
- Vue's 3 [Composition API](https://vuejs.org/guide/extras/composition-api-faq.html)
- Smaller bundle

Being able to use the components inside the `components/` directory, and any of Vue's API (`ref`, `watch`) anywhere in my app without importing them was an amazing developer experience, as well as the stores being auto-imported configuring them in the `nuxt.config.ts` file.

Nuxt 3 uses [Vite](https://vitejs.dev/) under the hood which provides a dev server and a build tool for modern web projects.

In addition, I used JWT tokens for authentication, which I later explain in this file. 

# 👀 What's contained in each file I created

## 📁 `api/`

The directory for my Django server. Contains all the `api/` app and the `main/` project generated by Django when starting a new project.

### 📂 `api/`

The directory for my main app. Contains all the boilerplate files generated by Django plus `auth.py`, `middleware.py`, `serializers.py` files for extra configuration.

> 📄 `admin.py`

The default file created by Django. I registered my models here in order to access them later on the Admin panel.

> 📄 `models.py`

I created the following models in here:

- **WorkSpace**

  The main container for boards. A workspace can have many boards.
  - `user` (foreign key)
  - **`name`**  The workspace's name

- **Board**
  
  The board the will be inside a workspace, a board can have many cards.
  - `user` (foreign key)
  - `name`
  - `workspace` (foreign key)

- **Card**
  
  The Card that will be inside a board. It will have a name and a description.
  - `user` (foreign key)
  - `name`
  - `description`
  - **`board`** (foreign key) For moving between boards.


> 📄 `auth.py`

The custom authentication used inside the settings under the `REST_FRAMEWORK.DEFAULT_AUTHENTICATION_CLASSES` dictionary. This helps our views to determine whether the user is authed using JWT's.

> 📄 `serializers.py`

This file is required for the Django Rest Framework. Its purpose is to serialize the data in our models. They allow querysets to be converted to native Python datatypes that can be easily be rendered to JSON.

They also allow parsed data from a request to be converted back into a model object and be saved after being validated.

In the classes inside this file I inherited from `ModelSerializer` which makes it easier to make a serializer for each of our models, we just need to specify inside the serializer in the class `Meta`,  the model it will be working with and the fields we want to serialize.

Most of the serializers do the same, except from the `BoardSerializer`:

- I included an extra option called `depth` with a value of 1, this allow us to access the data inside the cards and I overrode the `get_fields` function to serialize the data inside the `cards` field with the `CardSerializer`.

>  📄 `urls.py`

The urls of my api application. Here I imported the `routers` module from `rest_framework` to use the `SimpleRouter` class to register the ViewSets created on the `views.py` file which I will later explain.

**`api/` matching**
I prefixed all my routes inside the api app with the route of `api/` inside the `main/urls.py` file. So when the user visits the route of `api/<matching-route>` it routes them to the route inside the the api app.

Then in the `urlpatterns` list, inside `api/urls.py`, I registered the `me/` route to retrieve the current user logged in; auth routes `register`, `login`, `login` and I included the urls registered inside the router variable with the `include()` function with the route of `''` so when the user makes a request to the url of `api/workspaces/` the SimpleRouter of Django Rest Framework controls the route and calls the appropriate ViewSet, in this case, the `WorkSpaceView`. If the makes a request to `api/boards/` the router will handle it and call the appropriate ViewSet, the `BoardView`, and so on.

> **JWT Auth**

I'm using JWT based authentication using the [`djangorestframework-simplejwt`](https://github.com/jazzband/djangorestframework-simplejwt) pip package.

**Login Process**
To login the user has to make a request to the `login/` route with the user credentials, this route will return a success message and will save the `refresh` token inside the user's session and will set the `access` token as a cookie .

```json
// Request
{
	"username": "icarusgk",
	"password": "1234"
}

// Response
{
  "message": "Successfully logged in!"
}
```

From now on, the `access_token` cookie will be included in each of the requests made to the server using the option `{ credentials: 'include' }` inside the fetch options on the client.

When the `access_token` expires, the middleware inside the `middleware.py` file will check if the refresh token inside the user's session is still valid, and if it is, it will set a new `access_token` as a cookie on the client. If the refresh token is not valid anymore the middleware will log the user out and delete the cookies inside the client.

The `refresh` token is valid for 7 days and the `access_token` is set to expire every 24 hours for security sake.

> 📄 `views.py`

The `views.py` is where all my server logic is. I've included documentation inside each function inside this file.

I'm using class-based views, inheriting from [`viewsets.ModelViewSet`](https://www.django-rest-framework.org/api-guide/viewsets/#modelviewset) to create the views that Django Rest Framework's Simple Router will have. The `ModelViewSet` class will provide common actions for our models such as `list`, `retrieve`, `create`, `update`, `partial_update` and `destroy` without the need to explicitly declaring them, just when we need to provide extra functionality. We just need to provide the queryset, serializer and optionally permission classes or pagination classes. For example:

```python
class TagViewSet(viewsets.ModelViewSet):
  queryset = Tag.objects.all() # <- Queryset 
  serializer_class = TagSerializer # <- Serializer
  permission_classes = [permissions.IsAuthenticated] # <- Permissions
```

In some cases I overrode the `ModelViewSet` functions to suit the needs of my app. The `get_queryset` function for instance, I overrode it in order to return the current logged in user's data instead of returning all the users data.

After these `ModelViewSet` inherited views, I created [`APIView`](https://www.django-rest-framework.org/api-guide/views/) inherited class-based views. I chose this class for its ease of use. I've included the documentation inside the functions for these classes too.


### 📂 `main/`

The boilerplate Django `django-admin startproject` code. 

> 📄 `settings.py`

The settings for the project. I decided to use environment variables with the package `python-dotenv` (listed on the requirements.txt), to retrieve this variables. This variables exists in the `.env` file at the root of the project.

> 📄 `urls.py`

In this file I registered the routes inside the `api` application, and the urls needed for the rest_framework module authentication.

## 📁 `client/`

I'm using Nuxt 3 as the framework for my client with Vite as the blunder and dev server, as well as Tailwind CSS for easily styling components and DaisyUI for having built-in Tailwind components.

### 📂 `components/`

This is the folder where all my components are, these components are auto-imported by Nuxt 3 and are available globally throughout the app. It includes the following files:

> 📄 `Alerts.vue`

The component for showing alerts globally when an action is done, it transitions at the top right of the page. It uses the alert store which I will later talk about. It has three styles: success, error and info.

> 📄 `Board.vue`

Receives the board as a prop from the `workspaces.boards` v-for iteration. Contains the logic for creating a new card, deleting a card, managing the drop event of a card, deleting the board, and renaming the board. Finally it emits the `moveCard` event with the needed info, and the `deleteBoard` event which deletes the board from the parent data `workspace.boards`

> 📄 `Card.vue`

Receives the card a prop from the `board.cards` v-for iteration. Contains the logic for managing the drag event of a card, updating the card, and deleting the card. Uses the alert store for informing the user of the success of an action or the error of such. And finally it emits a `deleteCard` event which deletes the card with the specified id from the parent data `board.cards`.

### 📂 `layouts/`

> 📄 `default.vue`

The Nav-bar shown at the top of every page, it changes whether the user is logged in or not. If authed, it shows the username of the current user with the Logout button, otherwise it shows the Login and Register buttons.

### 📂 `middleware/`

> 📄 `main.global.ts`

The .global suffix ensures that the middleware is ran globally on our app. It detects if the user is logged in and prevents the user from visiting the `login/` and `register/` routes, it redirects them to the `/` path.


### 📁 `pages/`

#### 📂 `workspaces/`

> 📄 `[id].vue`

The `[id]` serves as placeholder for the dynamic route id that the path will have. So that when the user visits `workspaces/23` the boards inside the workspace with id of 23 are shown. [More on dynamic routes](https://nuxt.com/docs/guide/directory-structure/pages#dynamic-routes).

This file has the logic for fetching the workspace with the id of `[id]` from the Django server, moving the card from board to board with the needed REST API request, deleting the board from the fetched data, creating a board and renaming the workspace.


> 📄 `index.vue`

This file dynamically shows the workspaces if the user is authed, if it's not it show the welcome page. It has the logic for creating a new workspace and deleting a workspace, it uses the alert store as well for alert the user of the success of an action or the error of such.


> 📄 `login.vue`

The file that represents the `/login` route and is the page for logging into the app. It contains the logic for logging in the user with the appropriate REST API call, it uses the alert store as well as the auth store and the useRouter() function to redirect the user to the '/' home page when the user is successfully logged in.


> 📄 `register.vue`

The file that represents the `/register` route and is the page for registering into the app. It has the logic for registering a user using the appropriate REST API call, it uses the alert store as well as the auth store. If the registration was successful, the user is automatically logged in.

### 📂 `plugins/`

> 📄 `thirdParty.vue`

Registers third party plugins into our app. I registered the Popper component for global use and the autoAnimatePlugin in order to use the v-auto-animate directive through the app.

### 📂 `public/`

Contains the image for the main page.


### 📂 `stores/`

I'm using [Pinia](https://pinia.vuejs.org/) as my library of choice for state management.

> 📄 `alert.ts`

> 💡 The store for creating alerts that are available throughout the app.

I wanted to practice types and interfaces in TypeScript, so in this store I created the `AlertStyle` type with the different types of alerts there can be. Later I created an interface for the options of an alert. 

After this, I created the `defaultOptions` for any alert, and made the `AlertOptions` interface `Required`.

Finally I declare the `Alert` interface extending the `AlertOptions` plus an id and the message the alert will contain.

I found using interfaces more useful because you can extend them to other interfaces.

Inside the state, this store has an `items[]` array of type `Alert` that has all the alerts currently being displayed. When a new alert is created the `notify()` action is called which creates a new alert item with an unique id and pushes it to the items array. When 2 seconds are passed it removes itself from the items array with the `remove()` action. The `success()`, `error()` and `info()` actions use the `notify()` action with a custom style.


> 📄 `auth.ts`

> 💡 The store for managing the user and whether the user is logged in and dynamically display custom UI elements, it has an login action for global use.



### 📂 `types/`

The directory where I keep the types for the data I receive and send from and to the server.

### Rest of the files inside the directory

> 📄 `app.vue`

The mount point for the app. I declared the Popper styles in here as well as the `<Alerts />` component for global display.

> 🏔 `nuxt.config.ts`

The main configuration file for the Nuxt 3 app. It declares the modules it's going to need, the extra dirs we need auto-imported in the app, runtime public environment variables such as the server API request URL, and the external library we want to include in the SSR part of the app.

> `package.json`

This file keeps tracks of the dependencies in the app, as well as managing the scripts, the name and the version of the app.

> `tailwind.config.js`

This file is needed for the tailwind module. In here I declared the plugins I required for my app such as DaisyUI.

> `tsconfig.*.json`

TypeScript configuration files required by the app and Vite. 

# 🤔 How to run my application

**Setting up the server**

- Change directory to the client folder

```
cd server
```

- Create a virtual environment

```
python -m venv env
```

- Activate the virtual environment

```
source env/bin/activate
```

- Install the requirements

```
pip install -r requirements.txt
```

- Run migrations

```
python manage.py makemigrations api
python manage.py migrate
```

- Run the server

```
python manage.py runserver
```


**Setting up the client**

- Change directory to the client folder

```
cd ../client
```

- Install the dependencies

```
yarn install
```

- Run the project

```
yarn dev
```

- Go the project URL

```
http://localhost:3000/
```